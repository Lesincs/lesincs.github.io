---
title: 旋转数组的最小数字
date: 2020-09-19 10:28:50
tags: 
categories: 算法
thumbnail: /thumbnail/jf-brou-358069-unsplash.jpg
---
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为`1`。 

<!-- more -->

### 思路

碰到排序数组，首先想到二分查找。因为是旋转数组，所以数组是由左右两个递增数列构成的，并且最小的值在右边的递增数列开头的第一个。我们可以定义2个指针`p1`和`p2`，`p1`始终指向左边的递增数列并不断右移动，`p2`始终指向右边的递增数列，并不断向左移动。最终`p1`和`p2`相差`1`的距离时，`p2`对应的数就是最小值。

如下图所示：

Step(1):

![](https://i.loli.net/2020/09/19/N2fxhetkPdqG1zB.png)

Step(2):

![](https://i.loli.net/2020/09/19/EhNtf5zuUKCYowW.png)

Step(3):

![](https://i.loli.net/2020/09/19/nCO6rUzESgy4xce.png)

Step(3)之后，`p2`便指向我们要查找的最小数字。

思路找到了开始编码如下：

```kotlin
class Solution {
    fun minArray(numbers: IntArray): Int {
        if(numbers.isEmpty()) return -1

        var indexLeft = 0
        var indexRight = numbers.size - 1

        var indexMid = indexLeft

        while(numbers[indexLeft] >= numbers[indexRight]){

            if(indexRight - indexLeft == 1){
                indexMid = indexRight
                break
            }

            indexMid = (indexLeft + indexRight) / 2

            if(numbers[indexMid] >= numbers[indexLeft]){
                indexLeft = indexMid
            } else {
                indexRight = indexMid
            }

        }
        
        return numbers[indexMid]
    }
}
```

代码还考虑了如果没有旋转的情况，此时最小值应该是`indexLeft`。那么代码完美了吗？

### Special Case

考虑这样一种情况，对`[0,1,1,1,1]`进行可以旋转变成`[1,1,1,0,1]`或者`[1,0,1,1,1]`。对于第一种情况，我们的代码能正常计算出最小值为`0`，而对于第二种情况，计算出的结果却是`1`。

原因就是:**当indexMid, indexLeft,indexRIght在数组中对应的值相同时，代码只是粗暴的将indexLeft移动到了右边的递增区域，直接跨越了最小值的区域！！**

解决方法就是：碰到这种情况，我们手动的去查找最小值。修改代码如下：

```kotlin
class Solution {
    fun minArray(numbers: IntArray): Int {
        if(numbers.isEmpty()) return -1

        var indexLeft = 0
        var indexRight = numbers.size - 1

        var indexMid = indexLeft

        while(numbers[indexLeft] >= numbers[indexRight]){

            if(indexRight - indexLeft == 1){
                indexMid = indexRight
                break
            }

            indexMid = (indexLeft + indexRight) / 2

            if (numbers[indexLeft] == numbers[indexMid] 
                && numbers[indexMid] == numbers[indexRight]){
                return minInOrder(numbers,indexLeft,indexRight)
            }

            if(numbers[indexMid] >= numbers[indexLeft]){
                indexLeft = indexMid
            } else {
                indexRight = indexMid
            }

        }

        return numbers[indexMid]
    }

    private fun minInOrder(numbers: IntArray, indexLeft: Int, indexRight: Int): Int{
        var min = numbers[indexLeft]

        for (i in (indexLeft +1) .. indexRight){
            if (numbers[i] < min){
                min = numbers[i]
            }
        }
        return min
    }
}
```

Over！

