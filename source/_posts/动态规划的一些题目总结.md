---
title: 动态规划的一些题目总结
date: 2020-06-17 20:09:12
tags: 
categories: 算法
thumbnail: /thumbnail/jeff-brown-597952-unsplash.jpg
---

### 前言
最近在看动态规划相关的一些题目，这里做个总结。

<!-- more -->

### 斐波那契数列


$$
f(n)
\begin{cases}
\ 0,  &n = 0 \\
\ 1,  &n = 1 \\
\ f(n-1)+f(n-2),&n>=2
\end{cases}
$$

* 用递归可以快速简洁求解

```kotlin
fun getN(n:Int):Int{
    if (n == 0) return 0
    if (n == 1) return 1
    return getN(n-1) + getN(n-2)
}
```

递归求解写法简洁，但是带来的问题就是消耗比较多的栈资源，并且已经计算过的值会被重复计算。

* 使用备忘录数组优化，避免重复求值

```kotlin
fun getN(n:Int,mem:IntArray):Int{
    
    if (mem[n] != -1) return mem[n]
    
    val result = if (n <= 2){
        2
    }else{
        getN(n-1,mem) + getN(n-2,mem)
    }
    
    mem[n] = result
    return result
}
```

备忘录模式减少了重复求值的问题，但是避免不了栈帧消耗的问题，而使用动态规划可以完美的解决这两点。

* 动态规划

```kotlin
fun getN(n:Int):Int{

    val dp = IntArray(n+1)
    
    dp[0] = 0
    dp[1] = 1
    
    for (i in 2 .. n){
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n]

}
```

可以看出动态规划的核心就是从小到大，一步步计算出最后的值，下面看一个复杂点的例子。

### 锯木棍问题

> 一根木棍，每一米的价格不同，问长 n 米的木棍能锯出的最大价格是多少？

* 递归求解

  ```kotlin
  fun getMaxPrice(p:IntArray,n:Int):Int{
      
      // 木棍长度为 0，最大价格也是 0
      if (n == 0) return 0
      
      // 木棍长度为 1 米，最大价格为 1 米的价格
      if (n == 1) return p[0]
      
      // 其余情况，需要考虑单独情况。取最大值（依次从 1 米处开始锯，2米处开始锯...）
      var max = 0
      for (i in 1..n){
          max = max(max,p[i-1] + getMaxPrice(p,n-i))
      }
      
      return 
  }
  ```

* 备忘录模式

  ```kotlin
  fun getMaxPrice(p:IntArray,n:Int,mem:IntArray):Int{
  
      if (mem[n] != -1) return mem[n]
      
      var result = 0
  
      when (n) {
          0 -> result = 0
          1 -> return p[0]
          else -> for (i in 1..n){
              result = max(result,p[i-1] + getMaxPrice(p,n-i))
          }
      }
      
      mem[n] = result
      return result
  }
  ```

* 动态规划

```kotlin
fun getMaxPrice(p:IntArray,n:Int):Int{

    // dp方程代码下标长度的棍子能锯出的最大价格
    val dp = IntArray(n+1)
    
    // 很清楚的知道0和1时的取值
    dp[0] = 0
    dp[1] = p[0]

    for (i in 2..n){

        // p[j-1] 是锯出多少米的价格 而dp[i-j]是剩余长度随便锯的最大价格
        var max = 0
        for( j in 1..i){
            max = max(max,p[j-1] + dp[i-j])
        }
        dp[i] = max
    }
    
    return dp[n]
}
```

### 总结

上面的两道的动态规划都属于比较简单的线性模型，都还有一些复杂的模型如区间模型，帽子模型等等。因为不是搞算法的，就不去深究了，把一些简单的学会了就行了，不然容易丧失对算法的激情。