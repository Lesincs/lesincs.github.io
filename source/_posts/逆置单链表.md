---
title: 逆置单链表
date: 2020-06-29 20:22
tags: 
categories: 算法
thumbnail: /thumbnail/hamzah-hanafi-973624-unsplash.jpg
---

逆置单链表算是比较经典的链表题了，面试中出现得比较多；虽然它比较简单，但是解法比较多，并且涉及到了递归和复杂度，这里做个总结。

<!-- more -->

LeetCode上的题目如下：

> LeetCode - 206. Reverse Linked List
>
> Reverse a singly linked list.

* 解法一，使用数组

```kotlin
class Solution {
    fun reverseList(head: ListNode?): ListNode? {
        if (head?.next == null) return head
        
        val nodeList = mutableListOf<ListNode>()
        var vhead = head
        while (vhead != null){
            nodeList.add(vhead)
            vhead = vhead.next
        }
        
        nodeList.forEachIndexed { index, listNode -> 
            if (index == 0) {
                listNode.next = null
            } else {
                listNode.next = nodeList[index -1]
            }
        }
        
        return nodeList.last()
    }
}
```

思路很粗暴，使用一个数组保存所有链表的引用，然后遍历进行逆置。需要注意的是第一个节点的`next`应该指向`null`，然后应该返回数组的最后一个节点。这个写法很不简洁。即使是用`Kotlin`，代码依旧十分的冗长。如果追求简洁，可以使用递归，详见解法二。

* 解法二，递归

```kotlin
class Solution {
    fun reverseList(head: ListNode?): ListNode? {
       if (head?.next == null) return head
        
        val newHead = reverseList(head.next)
        head?.next?.next = head
        head?.next = null
        return newHead
    }
}
```

这里假设我们的函数能逆置某个单链表并返回头节点，而第一个`if`语句是递归的终点。而下面的代码怎么理解呢？看下图，假如一个顺序为1，2，3，4的单链表在某个递归时刻进行到了如下这一步。如图：

![](https://i.loli.net/2020/06/29/UmEJWYi6wfXy9ko.png)

此时，要完成逆置，我们需要使用 `head?.next?.next = head`将`4`号节点链接到了尾部，即`2`号节点的后面；此时`1`号节点的`next`节点还是`2`号节点，因此需要   `head?.next = null`来进行置空处理。借助图，也比较好理解逆置的流程。

递归写法虽然比较简洁，但是对栈帧有大量消耗，并且时间复杂度比较高，因此还有一种借助临时节点来逆置的算法。

* 解法三，使用临时节点。

思路是，我们使用一个`NEWHEAD`临时节点保持指向逆置后的头节点，并不断对原链表进行解构重组。

如图为某个时刻各自的指向：

![](https://i.loli.net/2020/06/29/9HdopiLOfqAEB2V.png)

结合图可以光速写出代码：

```kotlin
class Solution {
    fun reverseList(head: ListNode?): ListNode? {
        if (head?.next == null) return head

        var newHead:ListNode? = null
        var vhead = head
        while (vhead != null) {
            val next = vhead.next
            vhead.next = newHead
            newHead = vhead;
            vhead = next;
        }
        return newHead;
    }
}
```

这种解法时间复杂度为`O(n)`，并且没有消耗栈帧，算是一种比较推荐的解法。

### 结语

以上就逆置单链表常见的三种解法了，发现链表题如果想不明白画画图就很容易理解了。顺便吐槽一下用`Kotlin`写链表题的时候，由于函数参数默认是`val`的，所以不得不每次用一个`var`变量去遍历，还是挺麻烦的。