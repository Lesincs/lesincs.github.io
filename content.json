{"pages":[],"posts":[{"title":"LeetCode上的二分查找","text":"将 LeetCode 上二分查找相关的几道题目 AC 了，这里做个总结。 经典二分查找 LeetCode - 705 Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1. 题意比较好理解，给定一个已经排序好的数组，并给定一个 target 要求找到 target 在数组中的对应下标，若没找到，则返回 -1。 Kotlin 解法如下： 12345678910111213141516171819class Solution { fun search(nums: IntArray, target: Int): Int { var left = 0 var right = nums.size - 1 while (left &lt;= right){ val mid = (left + right) / 2 if (nums[mid] == target) return mid if (nums[mid] &gt; target){ right = mid -1 } else { left = mid + 1 } } return -1 }} 需要注意的点有： right 初始值为 nums.size - 1 ，这是为了与下面的 left &lt;= right 呼应。 中位数的值 &gt; target时，即说明 target的值可能在下标left（Inclusive） 和 mid（Exclusive）之间，所以要将查找范围向左收缩，即right = mid -1. 中位数的值 &lt; target时，即说明 target的值可能在下标mid（Exclusive和 right（Inclusive）之间，所以要将查找范围向右收缩，即left = mid +1. 前面说之所以用可能是因为 target的值可能根本不在当前的查找区间内，试想target值大于或者小于数组中的所有值的情况。 二分查找变种，返回最佳插入位置 LeetCode - 35 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 解法如下： 12345678910111213141516171819class Solution { fun searchInsert(nums: IntArray, target: Int): Int { var left = 0 var right = nums.size - 1 while (left &lt;= right){ val mid = (left + right) / 2 if (nums[mid] == target) return mid if (nums[mid] &gt; target){ right = mid -1 } else { left = mid + 1 } } return left }} 解法和经典查找几乎一模一样，唯一不同的是如果没查找到，返回left的值就行了。为什么返回left就可以了呢？其实可以这样考虑，while循环的条件是 left&lt;=right，而如果一直没有查找到，则进行最后一次循时必有left = right = mid，此时，对num[mid]和tartget的值的三种情况进行分析: nums[mid] == target,则表示查找到了，直接返回mid即可。 nums[mid] &gt; target，很容易得出target插入位置应该为mid，而恰好循环结束后，left = mid，即可以返回left。 nums[mid] &lt; target，很容易得出target 的插入位置应该为mid +1， 恰好循环结束后，left = mid +1,即可以返回left。 综上，我们只需要返回left的值就行了。 进阶，找到最左边和最右边的下标 LeetCode - 34Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 对于前面两道题，我们都预设了数组中有且仅有一个数字与tartget相同，这道题却不一样，他考虑到了，数组中有多个值和target相同的情况，并需要求出最左边和最右边的index。这道题有两种思路，第一种是按照经典方法找到和tartget对应的index之后，向左右两边继续搜索；另一种则是，找到target后对应的index之后，继续收缩边界，并在最后进行判断取值。第一种思路比较好理解，但是第二种方法维持了二分查找的连贯性。我们来看看采取第二种思路的解法。 解法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { fun searchRange(nums: IntArray, target: Int): IntArray { val result = intArrayOf(0,0) result[0] = findLeft(nums,target) result[1] = findRight(nums,target) return result } private fun findLeft(nums: IntArray, target: Int): Int { var left = 0 var right = nums.size - 1 while (left &lt;= right){ val mid = (left + right) / 2 if (nums[mid] &gt;= target){ right = mid - 1 } else { left = mid + 1 } } val candidate = right + 1 if (candidate &gt; nums.size -1 ) return -1 return if (nums[candidate] == target) candidate else -1 } private fun findRight(nums: IntArray, target: Int): Int { var left = 0 var right = nums.size - 1 while (left &lt;= right){ val mid = (left + right) /2 if (nums[mid] &lt;= target){ left = mid +1 } else{ right = mid -1 } } val candidate = left - 1 if (candidate &lt; 0) return -1 return if (nums[candidate] == target) candidate else -1 }} 先分析查找最左边index值的情况。假设到某个时刻，mid对应的值等于target，因为我们要找到最左边的index，所以我们继续将查找范围向左收缩，即right = mid -1，那么结束搜索后，right对应的值必定小于target,而right+1所对应的index的值是最接近target，并&gt;=target的值的。所以我们判断一下right+1的对应的值就行了，如果相等，说明找到了最左边的值；不相等，说明，没有查找到对应的值。但是，某种情况比较特殊，就是整个数组的值都小于target，此时搜索结束后，right+1越界了，所以我们需要考虑这种边界情况。 查找最右边的index值同理。假设到某个时刻，mid对应的值等于target，因为我们需要找到最右边的index，所以我们需要继续将范围向右收缩，即left = mid + 1,到最后，left的值必定大于target,而left-1所对应的值是最接近tartget并 &lt;= tartget的，同理进行判断就行了。此时也要注意所有元素都大于target的情况，循环结束后left = 0，因此也要先进行边界判断。 结语以上就是LeetCode上关于二分查找的几个典型的题，这里差不多就总结完了。","link":"/2020/06/17/LeetCode上的二分查找/"},{"title":"动态规划的一些题目总结","text":"前言最近在看动态规划相关的一些题目，这里做个总结。 斐波那契数列$$f(n)\\begin{cases}\\ 0, &amp;n = 0 \\\\ 1, &amp;n = 1 \\\\ f(n-1)+f(n-2),&amp;n&gt;=2\\end{cases}$$ 用递归可以快速简洁求解 12345fun getN(n:Int):Int{ if (n == 0) return 0 if (n == 1) return 1 return getN(n-1) + getN(n-2)} 递归求解写法简洁，但是带来的问题就是消耗比较多的栈资源，并且已经计算过的值会被重复计算。 使用备忘录数组优化，避免重复求值 12345678910111213fun getN(n:Int,mem:IntArray):Int{ if (mem[n] != -1) return mem[n] val result = if (n &lt;= 2){ 2 }else{ getN(n-1,mem) + getN(n-2,mem) } mem[n] = result return result} 备忘录模式减少了重复求值的问题，但是避免不了栈帧消耗的问题，而使用动态规划可以完美的解决这两点。 动态规划 1234567891011121314fun getN(n:Int):Int{ val dp = IntArray(n+1) dp[0] = 0 dp[1] = 1 for (i in 2 .. n){ dp[i] = dp[i-1] + dp[i-2] } return dp[n]} 可以看出动态规划的核心就是从小到大，一步步计算出最后的值，下面看一个复杂点的例子。 锯木棍问题 一根木棍，每一米的价格不同，问长 n 米的木棍能锯出的最大价格是多少？ 递归求解 12345678910111213141516fun getMaxPrice(p:IntArray,n:Int):Int{ // 木棍长度为 0，最大价格也是 0 if (n == 0) return 0 // 木棍长度为 1 米，最大价格为 1 米的价格 if (n == 1) return p[0] // 其余情况，需要考虑单独情况。取最大值（依次从 1 米处开始锯，2米处开始锯...） var max = 0 for (i in 1..n){ max = max(max,p[i-1] + getMaxPrice(p,n-i)) } return } 备忘录模式 1234567891011121314151617fun getMaxPrice(p:IntArray,n:Int,mem:IntArray):Int{ if (mem[n] != -1) return mem[n] var result = 0 when (n) { 0 -&gt; result = 0 1 -&gt; return p[0] else -&gt; for (i in 1..n){ result = max(result,p[i-1] + getMaxPrice(p,n-i)) } } mem[n] = result return result} 动态规划 123456789101112131415161718192021fun getMaxPrice(p:IntArray,n:Int):Int{ // dp方程代码下标长度的棍子能锯出的最大价格 val dp = IntArray(n+1) // 很清楚的知道0和1时的取值 dp[0] = 0 dp[1] = p[0] for (i in 2..n){ // p[j-1] 是锯出多少米的价格 而dp[i-j]是剩余长度随便锯的最大价格 var max = 0 for( j in 1..i){ max = max(max,p[j-1] + dp[i-j]) } dp[i] = max } return dp[n]} 总结上面的两道的动态规划都属于比较简单的线性模型，都还有一些复杂的模型如区间模型，帽子模型等等。因为不是搞算法的，就不去深究了，把一些简单的学会了就行了，不然容易丧失对算法的激情。","link":"/2020/06/17/动态规划的一些题目总结/"},{"title":"hexo的优化和备份","text":"前言最近发现之前搭的hexo访问速度比较慢，因为gitpage本来速度就不是太稳定，而我设置的封面图片又比较大，所以导致页面加载起来卡卡的，遂决定优化一下，同时把hexo源码备份到了hexo分支，防止源码丢失又得重建。 图片压缩我在hexo源码某个目录放了一堆unsplash图片用来作为封面，每次写博客随机取一张。下面是自己写的一个工具类，用于每次获取一个图片相对路径用于粘贴到博客正文里面。 12345678910111213141516object ThumbnailUtil { @JvmStatic fun main(arg: Array&lt;String&gt;) { val path = \"/Users/lesincs/Hexo-Original/themes/icarus/source/thumbnail\" val file = File(path) val prefix = \"/thumbnail/\" val names: MutableList&lt;String&gt; = ArrayList() file.listFiles()?.forEach { names.add(it.name) } val random = Random() println(prefix + names[random.nextInt(names.size)]) }} 但是我发现thumbnail目录下的图片都太大了，一般都是3m以上，甚至有的到达了十几m，实际上我们的blog只是为了美观，完全不需要这么大。于是决定将图片重新压缩下。 用kt写了一个简单压缩工具，用到了thumbnailator这个第三方库，本来是想用Luban的，但是只能用于Android Studio,只能作罢。工具类代码: 1234567891011121314151617181920object ImageCompressUtil { fun zip(fromDir: String, toDir: String) { val fileFromDir = File(fromDir) val srcPathsArray = Array&lt;String&gt;(fileFromDir.listFiles().size) { fileFromDir.listFiles()[it].absolutePath } Thumbnails .of(*srcPathsArray) .scale(0.25.toDouble()) .outputQuality(0.2f) .toFiles(File(toDir), Rename.NO_CHANGE) print(\"压缩完成\") }} 这样压缩之后，发现图片只有几十或者几百k了，然后重新部署，访问了下，图片加载速度是快了不少。 hexo源码备份有时，想要在多设备上更新blog怎么办？这就需要将hexo源码放到某个位置，然后每次取到本地，更新源码了然后重新部署，同时只要保障服务器的源码是最新的就行了，这样就能达到多设备更新以及备份的作用。 步骤： 首先，在hexo文件夹下建立git仓库 cd /hexo git init 建立hexo 分支并切换到hexo分支 git chekout -b hexo 提交文件 git add . git commit -m ‘add hexo source files’ 推送到远端 git remote add origin https://github.com/Lesincs/lesincs.github.io.git git push origin hexo 这样，hexo源文件就传到github上，需要的时候拉取下来就行了。 拉取的时候可以仅仅拉取hexo分支。 git clone -b hexo https://github.com/Lesincs/lesincs.github.io.git 最后最后也不知道写啥了，测试一下SM.MS图床吧。","link":"/2020/01/24/hexo的优化和备份/"},{"title":"使用IntentFlag来启动Activity","text":"虽然有Android有四大启动模式，但是实际上开发中，如果仅仅依靠在xml指定launchMode的形式来启动Activity，不太够用并且不太灵活。所以这篇文章探究下在一些常见的场景如何仅仅利用IntentFlag的形式来启动Activity。 场景一:在Service中启动Activity我们在MainActivity中放置一个Button，点击Button会开启一个Service，在Service的onStartCommand中，我们反过来启动MainActivity。 MainActivity的代码： 12345678override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) bt_main_activity.setOnClickListener { startService(Intent(this,MyService::class.java)) }} MyService中的代码： 1234override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { startActivity(Intent(this,MainActivity::class.java)) return super.onStartCommand(intent, flags, startId) } 接着我们启动App，点击MainActivity中的Button，猜怎么着？在我的Android 7.0设备上正常启动了MainActivity，而在我的模拟器上（Andorid 10）上面却崩溃了。错误如下: Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 查阅官方文档： 也就是说在Android 7.0以下或者Android 9以上Service或者在Application中启动Activity，必须加上FLAG_ACTIVITY_NEW_TASK这个Flag；而因为一个bug，这个要求在Android 7.0中不是强制的。无论如何我们在Service中加上这个Flag就可以了。 Service中的代码变成了这样： 1234567override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { startActivity(Intent(this,MainActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }) return super.onStartCommand(intent, flags, startId)} 修改之后，两个设备都正常启动了MainActivity，此时发现任务栈中存在了2个MainActivity。 其实这里比较奇怪，按照书上说的，FLAG_ACTIVITY_NEW_TASK等于launchMode中指定singleTask，也就是栈内复用模式。可实际上还是启动了2个MainActivity。我以为是在Service中启动的问题，可实际上就算是在MainActivity中启动，也还是会启动两个MainActivity。所以说还是不能全信书本，应该自己多实践。 继续，如果想只启动一个MainActivity，可以借助FLAG_ACTIVITY_SINGLE_TOP这个Flag，表示启用栈顶复用模式，因为MainActivity在栈顶，所以不会重新创建。 修改Service代码： 12345678override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { startActivity(Intent(this,MainActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP) }) return super.onStartCommand(intent, flags, startId)} 测试结果：加上这个Flag之后，MainActivity没有重建，其onNewIntent得到回调。 此时，考虑一种情况。如果我们是在SecondActivity中启动了Service，此时SecondActivity在栈顶了。如果此时再用FLAG_ACTIVITY_SINGLE_TOP这个Flag，肯定还是会重建MainActivity，测试一下。 我们由MainActivity启动SecondActivity,在SecondActivity再启动Service。 经测试，不改变Service代码的情况下。Service启动后，任务栈有三个Activity，分别是MainActivity-&gt;SecondActivity-&gt;MainActivity。 如果我们只想保留一个MainActivity怎么办呢？此时可以使用FLAG_ACTIVITY_CLEAR_TOP这个Flag。 修改Service代码如下： 12345678override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { startActivity(Intent(this,MainActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) }) return super.onStartCommand(intent, flags, startId)} 此时运行一下，发现任务栈确实只有一个MainActivity了，不过该MainActivity重建了。如果我们不希望他重建怎么办呢？FLAG_ACTIVITY_CLEAR_TOP的文档中有一段话： 12&gt; The currently running instance of activity B in the above example will either receive the new intent you are starting here in its onNewIntent() method, or be itself finished and restarted with the new intent. If it has declared its launch mode to be &quot;multiple&quot; (the default) and you have not set {@link #FLAG_ACTIVITY_SINGLE_TOP} in the same intent, then it will be finished and re-created; for all other launch modes or if {@link #FLAG_ACTIVITY_SINGLE_TOP} is set then this Intent will be delivered to the current instance&apos;s onNewIntent().&gt; 可以知道，如果想避免重建可以加上FLAG_ACTIVITY_SINGLE_TOP。 修改Service代码： 123456789override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { startActivity(Intent(this,MainActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP) }) return super.onStartCommand(intent, flags, startId)} 再次测试，同样的步骤MainActivity没有重建。onNewIntent方法得到回调。 场景二：在Activity中启动Activity。试想一种场景，你在一个层级比较深的Activity，需要返回到MainActivity，并且不能销毁MainActivity，可以怎么做？其实和场景一一样，只是我们不需要加FLAG_ACTIVITY_NEW_TASK这个Flag。 修改代码，在SencondActivity中跳转到ThirdActivity，并由ThirdActivity跳转到MainActivity。 ThirdActivity代码如下： 1234567bt_third_activity.setOnClickListener { startActivity(Intent(this,MainActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP) })} 经测试，效果达到，任务栈中只有MainActivity，并且未重建，onNewIntent回调。 场景三：从通知中启动Activity。我们根据场景2修改代码，在ThirdActivity中弹出个通知，并且希望点击通知回到MainActivity。 代码如下： 123456789101112131415161718bt_third_activity.setOnClickListener { val intent = Intent(this, MainActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP) } val pendingIntent = PendingIntent.getActivity(this, 0, intent, 0) val ntf = NotificationCompat.Builder(this, \"id\") .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\"title\") .setContentText(\"text\") .setContentIntent(pendingIntent) .build() val notificationManager = getSystemService(Service.NOTIFICATION_SERVICE) as NotificationManager notificationManager.notify(2, ntf)} 测试发现IntentFlag无效了，在so上找到一个答案https://stackoverflow.com/questions/24873131/android-clear-task-flag-not-working-for-pendingintent 发现不能将PendingIntent的requestCode设置为0。修改成不为0之后效果达到和场景二一样。 修改代码如下： 1val pendingIntent = PendingIntent.getActivity(this, 1, intent, 0) 场景四：清除栈内所有Activity这种情况比较常见的是token过期，需要清除栈内所有Activity，然后启动登录界面。我们假如ThirdActivity是登录界面。在任务栈栈内存在MainActivity，SecondActivity的情况下，此时token过期了。这时我们需要启动ThirdActivity。 此时我们需要用到FLAG_ACTIVITY_CLEAR_TASK 这个Flag，并且，文档表示该Flag必须和FLAG_ACTIVITY_NEW_TASK一起使用。我们试一下不一起使用会怎么样： SecondActivity代码： 123456bt_second_activity.setOnClickListener { startActivity(Intent(this,ThirdActivity::class.java) .apply { addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK) })} 经测试，如果不添加FLAG_ACTIVITY_NEW_TASK，任务栈并没有被清空， 加上之后效果正常。 结语以上就是上面就是常见的几种使用Flag来启动Activity的场景。熟练之后肯定是比在xml中指定更加灵活的。","link":"/2020/07/22/使用IntentFlag来启动Activity/"},{"title":"在macOS上使用Charles在Android 7.0设备上抓包","text":"Android 7.0以上使用Charles对Https协议的抓包稍微繁琐了些，这里记录下步骤。 1.下载Charles。官网地址:Charles官网。Charles是收费软件，但有30天的免费体验时长。 2.开启Https抓包进入Charles，工具栏选中Proxy，点击SSL Proxying Setting。 然后增加一个如下图所示的配置，表示抓取所有域名的443端口的请求，443也就是https协议的默认端口。 3. 手机端WiFi开启代理手机端需要和mac处在同一局域网，并且在WiFi处开启代理。代理服务器地址为mac的ip地址，可以通过如下方式查看： 按住Option ，然后点击mac的WiFi图标，会出现如下界面，红框处就是mac的ip地址。 第二种查看方式就是进入终端，输入 ifconfig命令，红框处就是ip地址。 至于端口号，可以在Charles的Proxy-&gt;Proxy Setting 中看到，默认是8888。 代理设置完成之后，手机的网络请求边会通过Charles代理。此时，一般的Http请求都能抓取到了，但是Https还会存在问题，继续配置。 4.手机端安装证书 先将Charles的证书下载到mac本地。 进入Charles，依次点击Help-&gt;SSL Proxying-&gt;Save Charles Root Certificate，然后选择存储路径之后，点击保存。随后就可以在保存位置看到一个名为charles-ssl-proxying-certificate.pem的文件。 进入Terminal，cd 到刚才选择的存储目录。执行： 1openssl x509 -subject_hash_old -in charles-ssl-proxying-certificate.pem 然后复制红框部分： 退出终端，将我们的charles-ssl-proxying-certificate.pem重新命名为 复制的内容.0，拿我这个举例子也就是fae0edc7.0。 将上面文件导入到Android手机的/system/etc/security/cacerts 目录。然后重启手机。大功告成。 5. 一些小坑 4.4重命名这一步，我用mac自带的重名命方法，无法更改后缀。最终还是通过Terminal完成。执行的命令为： 1mv charles-ssl-proxying-certificate.pem fae0edc7.0 4.5将证书导入到Android手机这一块，因为我的手机已经root过了，所以是将文件传到手机的sdcard目录之后，再在手机上通过RE管理器进行的导入。如果手机未root的话，应该可以通过adb进行一些目录授权再导入，因为时间有限，我也就没折腾了，具备一台已经root了的开发机还是很有必要的。","link":"/2020/07/15/在macOS上使用Charles在Android 7.0设备上抓包/"},{"title":"如何书写自己的英文地址","text":"最近入职了ThoughtWorks，因为是外企公司，签合同的时候需要用到自己的英文地址，一时之间还不知道怎么写。 当时就凭着感觉随便写了，因为我的中文地址是：xx省xx县xx镇xx村xx组，于是我写在合同上的地址如下： 1xx province xx county xx town xx street xx group。 其中xx代表具体的地方，我是用拼音写的，并且遵循第一个首字母大写其余全部小写的原则。 然后下来之后我觉得这个挺有意思，于是Google了一下，找到一个网站可以将中文地址转换为英文地址:中文地址转英文地址，然后我键入了我的地址，转换了下。转换出来的形式应该是比较规范的，如下： 1No.xx Group, xx Village, xx Town, xx County, xx. ps：这里的最后一个xx是省份。 可以发现他的格式： 区域由小到大从左到右书写 最后的省份不用加Province 所有的区域单位需要大写 好了，学到了，以后再也不用担心不会写英文地址了。 这两天入职发现要学习的东西好多好多，如火如荼的S10比赛也看得不香了，希望自己加油冲冲冲。","link":"/2020/10/11/如何书写自己的英文地址/"},{"title":"成都洗牙全过程","text":"前言从小到大其实没太关注口腔健康方面的东西。第一次看到洗牙这个词语应该是在头条上面看了一个洗牙相关的视频，视频感觉比较重口没细看，倒是评论看了一些，印象中说洗牙好的基本没有，全是一些类似‘’洗牙之后牙缝变大，牙齿酸痛‘’等等之类的对洗牙有着贬义的评论；并且当时自己对洗牙也不是很了解，还以为是对牙齿美白的一种方式，所以内心也是一种排斥的感觉，所以也就不以为然。但是后面偶尔也在v站看到一些关于洗牙的讨论，这里大多数人对洗牙却是另一种态度，几乎是一边倒的安利，这导致我对洗牙的看法又逐渐好了起来，觉得其应该是一种科学的牙齿护理方式，之前可能存在误会。 前两天更是看了某位网友的分享:我看牙医的经历，让我下定决心择日去洗一次牙。 牙齿的状态目前为止自知牙齿的状态不是很好，偶尔会有牙齿无力，酸痛的感觉。印象中小些的时候，牙齿还是能做开瓶盖这些操作的。但是到后面一些，感觉牙齿没那么坚硬了，可能是糖吃多了？从高中开始，喜欢喝可乐和吃薯片，一直持续到现在；而且上了大学之后，喜欢喝冷饮，如果再配上热的食物，那就是冷热刺激，这无疑又加重对牙齿的伤害。总之，牙齿的情况不是太乐观。 医院的选择因为听说洗牙只是一个比较常规的操作，只要设备正规，注重卫生就可以了。所以我是在美团上团购的一家比较近的评分还比较不错的口腔专科医院的洗牙套餐。它家洗牙一共有三个套餐可供选择，轻度、中度和深度。轻度适用于定期洁牙的，只需要79块钱，做一些轻微的清理工作。而深度洁牙是最贵的，也是最彻底的，当然我应该还没到那种程度，就选择了中度的，原价188RMB，团购下来还便宜了五十多块钱。 时间的选择时间最好是选择在早上，这样出了什么意外状况下午可以返回进行治疗处理，刚好我这就出了点状况，当然洗牙一般不会出啥大问题。 洗牙全过程我是预约的早上九点的洗牙，因为刚好今天是上班时间，所以其实也没什么人。一去就给安排上了，医生把我带到了一个小房间。房间里面放置了一个专门用于洗牙的仪器。描述一下仪器的话就是，一个可以调整角度的躺椅，上面带有一个探照灯，然后旁边带了一个出水的装置，装置下面有一个塑料水池用于患者漱口，大概情况就是这样。医生示意我躺下，然后他帮我调整了躺椅的角度到一个合适的位置，然后就开始了给我洗牙。第一步是检查牙齿情况。医生会让你张开嘴，然后拿一个带有一个圆形镜子的探测镜子，在你嘴里到处翻动，检查你所有的情况。完毕之后，医生告诉我我有两颗龋齿，并且还给我拿了一面镜子让我自己看一下。之前就发现自己有几颗牙齿咬合面有一些黑黑的纹理，还以为是刷牙没刷到位引起的一些沉积，现在才知道那是龋齿，又名蛀牙，单纯靠刷牙已经是解决不了问题的了，如果不及时的治疗，整个牙齿最终会彻底坏掉。牙齿检查完了就开始洗牙了。医生会先让你淑下口，然后拿一张mask将你的脸蒙上，只露出嘴巴和鼻子，不得不说这是个好东西，因为不像某手术一样需要在特级隐私部位进行操作，但是口腔毕竟也是人们比较隐蔽和敏感的部位，蒙上之后会让你减少你的羞耻感，也方便了医生操作。之前听别人说洗牙的感觉就是感觉牙医拿着电钻在转你的牙齿，实际上的体验还真是这种感觉。你会感受到有一个尖锐的东西，类似于螺丝刀的头部，在你的牙缝之间不停转动的感觉，其实不是转动，是超声波震动，和电动牙刷类似，因为自己使用电动牙刷已经有一段时间，所以还是挺习惯的。医生会顺着所有牙齿挨着一个一个进行这种操作，把你的牙结石给你清理出来。我一共30颗牙齿（28颗正常牙齿 + 2颗智齿），大约20颗只有酸麻酸麻的感觉，还有7、8颗多了些轻微的疼痛感，剩下一两颗有比较剧烈的疼痛感，以至于我不得不示意医生停下来。清理过程中，医生会给你喷一种喷雾，具体是啥我不知道，可能是漱口水用于杀菌吧，然后由于你的口腔有异物，你会分泌大量的口水，这样你口腔就会积累大量的液体，导致你会很想呕吐的感觉，对于这点，医生的办法就是有一根吸水管会不停的吸收你口腔里面的水分，这样如果医生操作得当的话，你几乎不会有想呕吐的感觉，但是我中间还是有两三次有这种感觉，因为不想影响医生操作，以至于我吞了几次口水，难受。在第一轮清洗的时候，你会明显的感觉到你的牙结石的存在，牙结石掉落时，首先是口腔会有感知，其次，你会闻到自己牙结石的味道，这味道怎么说呢？反正你会觉得医生很伟大，简直就是天使。第一轮清洗之后，医生会让你漱一下口。漱口之前会让你先吐出口腔中的液体，基本上就是夹杂着唾液，血和牙结石…会有点不忍直视。然后喝点水淑下口就会好很多。之前听网上有人说自己洗牙时大口喷血，我觉得我的出血量还比较少，说明牙结石不是很严重。第一轮洗牙之后，就进入第二轮，第二轮就是把之前没有清洗到的地方再 着重清洗一遍，步骤也和之前是一样的，没啥好说的。第二轮完成了，差不多洁牙也就完成了。然后进行了一个附赠的抛光处理，就是用磨光器清除牙面，类似于比较深度的刷牙。抛光处理之后淑了个口，然后医生给上了点药，嘱咐了一些注意事项，然后本轮的洗牙也就到此为止。总共花费了也就四五十分钟吧。 洗完牙之后的感受因为洗完牙上了药，这个药特夸张，有一种洁厕灵的味道，这会导致你口腔很不舒服，会一直分泌唾液；其次就是洗牙之后牙齿有一种酸软的感觉，医生说过了一两天就会好了；至于网上说的感觉牙缝变大，自我感觉并没有。 插曲回家之后,我发现门牙这一块有一个小小的缺口，虽然挺小，但是看起来挺渗人的，毕竟是门牙啊啊啊。所以联系了医生，医生说是牙齿矿化引起的脱落，让下午去做个免费的修复手术。于是下午又屁颠屁颠跑过去了，这次来了个比较专业的医生，看了下说不是矿化引起的脱落，而是由于龋齿导致的牙齿坏掉，洗牙刚好把外面坏的那块“震”下来了，当时就躺在那听医生一顿分析，心理很是难受，没想到年纪轻轻，门牙就坏掉了，以前的快乐水喝得爽，现在报应来了。最后，医生提了个方案，就是把坏死的东西磨出来，然后用树脂补上，当时那种情况，弱小可怜又无助，就是医生说什么就是什么吧，于是就让医生给做了。速度也很快，也就十几分钟。做完之后照镜子发现缺口不见了，美观程度很不错。树脂的真实度很高，但是门牙那里有很明显的异物感，医生说隔天就好了。一开始很膈应，觉得年纪轻轻就用人工材料补牙了， 不舒服。但是转念一想，坏死的东西堆积在那和人工材料其实区别不大，并且还会加快牙齿的坏死。而且从美观程度上来说，确实还不错，也就释然了。至此，洗牙就告一段落了，可能近期会考虑去把两个龋齿修复下，不过价格也是不菲啊，最差的一颗也要180，只能在考虑下。 总结这次的洗牙，收货最大其实是自己对自己牙齿健康的一种心理上的重视，一种危机感。在这之前，虽然知道某些东西对牙齿危害比较大但还是乐此不彼的尝试着，在意识到危害之后，以后在这方面应该会注意。 Flag最后，为了自己牙齿的健康，立几个flag吧 不再喝任何碳酸饮料 每天刷牙次数由1次提升至2次 少喝奶茶，少吃薯片，少喝冷饮","link":"/2019/09/29/成都洗牙全过程/"},{"title":"旋转数组的最小数字","text":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 思路碰到排序数组，首先想到二分查找。因为是旋转数组，所以数组是由左右两个递增数列构成的，并且最小的值在右边的递增数列开头的第一个。我们可以定义2个指针p1和p2，p1始终指向左边的递增数列并不断右移动，p2始终指向右边的递增数列，并不断向左移动。最终p1和p2相差1的距离时，p2对应的数就是最小值。 如下图所示： Step(1): Step(2): Step(3): Step(3)之后，p2便指向我们要查找的最小数字。 思路找到了开始编码如下： 1234567891011121314151617181920212223242526272829class Solution { fun minArray(numbers: IntArray): Int { if(numbers.isEmpty()) return -1 var indexLeft = 0 var indexRight = numbers.size - 1 var indexMid = indexLeft while(numbers[indexLeft] &gt;= numbers[indexRight]){ if(indexRight - indexLeft == 1){ indexMid = indexRight break } indexMid = (indexLeft + indexRight) / 2 if(numbers[indexMid] &gt;= numbers[indexLeft]){ indexLeft = indexMid } else { indexRight = indexMid } } return numbers[indexMid] }} 代码还考虑了如果没有旋转的情况，此时最小值应该是indexLeft。那么代码完美了吗？ Special Case考虑这样一种情况，对[0,1,1,1,1]进行可以旋转变成[1,1,1,0,1]或者[1,0,1,1,1]。对于第一种情况，我们的代码能正常计算出最小值为0，而对于第二种情况，计算出的结果却是1。 原因就是:当indexMid, indexLeft,indexRIght在数组中对应的值相同时，代码只是粗暴的将indexLeft移动到了右边的递增区域，直接跨越了最小值的区域！！ 解决方法就是：碰到这种情况，我们手动的去查找最小值。修改代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { fun minArray(numbers: IntArray): Int { if(numbers.isEmpty()) return -1 var indexLeft = 0 var indexRight = numbers.size - 1 var indexMid = indexLeft while(numbers[indexLeft] &gt;= numbers[indexRight]){ if(indexRight - indexLeft == 1){ indexMid = indexRight break } indexMid = (indexLeft + indexRight) / 2 if (numbers[indexLeft] == numbers[indexMid] &amp;&amp; numbers[indexMid] == numbers[indexRight]){ return minInOrder(numbers,indexLeft,indexRight) } if(numbers[indexMid] &gt;= numbers[indexLeft]){ indexLeft = indexMid } else { indexRight = indexMid } } return numbers[indexMid] } private fun minInOrder(numbers: IntArray, indexLeft: Int, indexRight: Int): Int{ var min = numbers[indexLeft] for (i in (indexLeft +1) .. indexRight){ if (numbers[i] &lt; min){ min = numbers[i] } } return min }} Over！","link":"/2020/09/19/旋转数组的最小数字/"},{"title":"一个 Android 猿的九月面试&杂谈","text":"今天是九月的最后一天，也是我 25 岁的生日，Time flies。还好经过一个月的求职，我拿到一个比较满意的 Offer，也安排好了节后入职，这让时间和工作带给我的焦虑感变得不那么强烈。于是我决定在今天将自己这个月求职的过程以及自己的心路历程记录下来，算是一个总结以及反思。 被迫离职时间退回到七月上旬的某个星期五上午，我突然收到我们人事部消息，让我去她办公室聊一聊。入职快一年，这是第一次和人事部的主管进行面对面聊天，结合公司前前后后的一些情况，我已经预感到有不好的事情发生了，当时还苦笑着想到了“鸿门宴”这个词语。 果然，主管那边还是以委婉的方式告诉我我被裁员了。得益于日常在 V 站摸鱼，见过太多维权的帖子，对劳动法竟然也有了潜移默化学习。因为我当时入职公司 11 个多月，所以按照劳动法，是需要给到 1 个月的赔偿，又因为是立即通知走人，没有给我 30 天的缓冲时间，还需要额外追加一个月的工资，所以是需要给到我 2 个月的赔偿。于是我就这样提了 2 个月赔偿的诉求，然后人事这边就让我下去了。 因为是周五上午通知的，所以下午也就在复杂的心情中摸了摸鱼，也就过去了。假期的两天呢，因为也担心公司那边搞一些骚操作，所以自己也做了做准备。比如：熟读了几遍劳动法，把对自己有利的几条看了一下；把之前的一些打卡记录，邮件备份了下；翻出了之前的劳动合同看了看等等，总之就是做了比较坏的打算。 周一正常到了公司，因为我们公司有开早会的习惯，本来下意识的准备去参加的，可是想了想自己当时的处境，觉得没什么必要了，于是直接回到了工位。然后一上午没有收到任何的消息，差不多中午的时候人事给我发了个填离职信息的单子，然后到下午，被拉去谈话，同意了我的赔偿诉求，于是就签了字，下午收拾了细软就走了。因为离职证明还得第二天来拿，所以第二天下午又到了公司，和另外一个被裁员的同事一起请了公司几个关系比较好的哥们一起吃了顿饭；现在只记得那天喝了不少酒，回去之后昏昏沉沉的就睡过去了。 迷离的 2 个月因为拿到了一笔赔偿，并且当时是七月份，工作岗位不是太多。所以我当时的计划是在一种休闲的状态下保持一定的学习，然后等到 9 月再开始求职。我捡起了好久没玩的 LOL，上了几波分，才发现好久没玩了，但是还是跌跌撞撞上到了白金。一直到了七月末，内心产生了些许的堕落感，并且游戏也有点腻味了。因为我在网上了解到有自习室这种东西的存在，于是在美团上面看了看，果然是有的，并且我住地方附近就有一家。于是我第二天就去体验了一天。我大概描述一下它的环境和体验：我去的地方是一个上下楼，进门后就是前台，前台会有一些人帮你安排一些事宜，前台后面就是楼梯了，可以到二楼；一楼有两排书桌，有一个卫生间，还有一个小小的用于吃饭的房间，以及饮水机；二楼就全是书桌了，大概六七排；这种书柜和大学宿舍的书柜很相似，但是宽度可能只有大学宿舍里面的一半。我观察了一下，这里前台的接待人员不是固定的，并且他们也并不是专门的前台人员，通过他们看的一些资料猜测他们应该是考研一族，然后在这里做兼职。然后就是整个自习室的氛围，可以说是很好了，大家都很安静的在学习，总体体验和大学的图书馆类似。 因为第一天体验不错，于是我就办了个月卡，然后每天背着一本《Android开发艺术探索》去自习室学习了；就和正常上下班一样，过着朝九晚六的生活。看上去似乎还挺充实，但是学习毕竟是枯燥无味的，加上我自身自控能力不是很好。我可能看了某个章节，就会忍不住的去刷一刷 Bilibil 或者 Youtube ，看看我关注的 Up 主有没有上传新的视频，或者去逛逛 V 站，看看有没有什么瓜吃…总之，整体的一个效率只能算一般，这就导致我看完这本书花了很多的时间。 就这样一直到了八月初，有一个朋友来了成都，于是我也停下了去自习室的步伐，找几个死党就聚了聚，一起玩了几天。 之后的日子一直到九月初，就比较浑浑噩噩，以至于我现在回忆起来都没什么印象了。大概做的事情就是打游戏，看比赛以及偶尔准备准备面试。 九月初，我在成都还没有进行任何的一个面试，因为我本人是喜欢把一切准备妥当再去面试，再加上成都当时 Boss 上联系我的都是一些小公司和外包公司，我不是太想去，就一直没理睬。然后因为和一个北京的朋友经常聊天，他建议我去北京去看看机会。因为我对北京是比较向往的，即使不是因为找工作，我也会很想去看一看，于是我就抱着找工作以及旅游的心态，订了去北京的机票。 北京，北京9 月 4 日，我早早起了床，去赶到北京的飞机。因为是夏天，所以我的装备也就带得比较简单：几件衣物，然后电脑，充电宝等。到机场等待的时候，想着有可能会在北京会找到不错的机会，以后就在那边上班；也就会告别两年多工作和生活的成都，突然就感觉成都这地方真是太好了，吃喝玩乐样样不差，生活节奏也很慢，我想这就是为什么我很多的外地朋友会选择在成都安家的原因吧。 因为我的航班不是直达航班，中停了一小时。所以我即使 11 点出发，也是在接近下午 5 点的时候才到达了北京的大兴机场。和朋友商量在西二旗碰头。据说西二旗算是北京一个比较拥挤的地铁站，类似于成都的天府广场，火车南站，有过之而无不及。而且这里周围互联网企业也比较多，所以大量程序员会在这里聚集。我到这里的时候接近 6 点，恰逢下班晚高峰，但可能是因为疫情的原因，人数没有传说中的那么吓人。 在西二旗到处观瞻了一下，不一会儿，我和我北京的唯一亲信–我朋友碰头了，颇有老乡见老乡的感觉，然后我俩就边寒暄边往他住的地方赶。他是住在昌平线上的某个小区，下了地铁还需要坐一个站的公交。坐公交的时候我发现北京的公交坐到不同的站的价格是不一样的，所以也就需要上下车都需要刷一刷卡，比较繁琐。之前在成都，坐过几次公交车都是固定的价钱，上车的时候刷一次就够了。辗转反侧就到了他住的地方。他住这里的房租相对来说还挺便宜，即使是相对比较贵一点的自如价格也不到 2000，但是面积比较小，不到我在成都的房间的 1/2。 第一次到北京，肯定先得到处玩一玩。因为当天是周五，我们便计划是周六先去长城玩，然后周天去故宫，所以当晚约了个第二天 9 点去八达岭的顺风车，就睡下了。 第二天早上如约和司机碰面了，风风火火一个小时不到就把我们送到了景点。当天的天气还不错，有太阳，晒但是不是很热。到达景区之后，先是排队，然后做了十几分钟的大巴之后，达到了徒步登长城的地点。再走了几分钟，便见到了传说中的长城，awesome！当天游玩的人数不算特别多。我们的游玩路线是先徒步爬了南城，然后返回起点爬北城，最后做滑车离开。我的体验是南城的比较陡峭，对于我这种很久不运动的人来说，要南四楼那一段比较吃力，不过咬咬牙还是能上去；北城则不是太陡，但是距离相对较长一些，顶部那里人聚集特别多。至于那个滑梯，很奇怪的体验，像玩具车一样，80 RMB/人感觉不是很值，如果可以再来一次，我会选索道。 滑梯的终点就可以直接做直通市内的大巴车。当时逛完长城差不多下午三四点，还比较早，于是就去鼓楼周围逛了逛。估计是因为疫情，鼓楼已经封闭，只能在外面看一看了。观看的时候居然碰到 107 路公交车经过。作为雷子老粉了，脑海中突然蹦出那句歌词，“当 107 路再次经过，时间是带走青春的电车。” 鼓楼看完，就去了周围的烟袋斜街，里面也是一些吃的喝的居多，没什么特别的。 完了之后恰逢《信条》刚上映，就买了两张 iMax 电影票，准备去看看。事实证明这是个错误的决定，因为早上八点就起床，一天没有休息然后还消耗了大量的体力，当时的我已经很累很困了，然后又是《信条》这部电影。反正结果就是两个多小时的电影，我差不多一半时间都在睡觉，朋友倒是一秒不差的看完了，不过问了问他他说他也没怎么看懂。 看完之后回到小区已经十二点多了，又去深夜放毒了一波，吃了顿烧烤，喝了北京的扎啤。回去了之后，躺在床上，想了想第二天早上预约的故宫，和朋友商量了下决定还是取消了，因为当时感觉整个人都快虚脱了，第二天肯定起不来。 果不其然，第二天差不多都是睡过去的。就这样，周末就过去了，故宫也没去成，算是留了个遗憾。接下来的一周便是我的面试之旅了。 周一 百度健康部（14:00 - 15:00） 这次面试 Boss 上百度的 HR 主动联系我的，发送简历之后，那边通过筛选，简历过了，于是给安排了一次视频面试。 主要问到的问题： 什么是序列化和反序列化？ 序列化是指将对象转换成可以传输或者存储的形式的过程。而反序列化是其的逆过程。 Serializable 和 Parcelable 的区别 Serializable 是 Java 标准库提供的一个接口，它的优点就是使用比较简单，缺点就是使用到了反射，并且在序列化的过程中，会进行 IO 操作。Parcelable 是 AndroidSDK 提供的序列化接口。他需要开发者显示的去实现序列化和反序列化的过程，但是它的速度和效率都会优于 Parcelable 了。在 Android 中，推荐使用 Parcelable 来进行序列化和反序列化，像常见的 Intent 类，Bundle 类都实现了 Parcelable接口。 介绍下之前的技术团队 这里说下我的情况，我之前在一家小公司，Android 一共也只有 2 个人，大多数时间是独立开发。这点可能是减分项，毕竟对于大厂会考虑更多的团队合作。 介绍下之前做的项目 我讲了我之前的项目的主要的面向人员和主要的涉及的一些功能。关于项目介绍的问题肯定是会被问到的，一定要准备好。 之前做的项目遇到的最大困难是什么 说实话被问到这个问题，我大脑一片空白的。因为作为码农，在工作中肯定是会遇到很多问题的，具体的可以分为 2 大类：技术问题和团队协作问题。而这两类实际上都是需要提前准备好的。对于技术问题，一般是技术挑战或者难解决的 Bug ，一般在技术面试上可以回答，可以用简短的话描述一下遇到的场景，以及自己解决问题的思路；而团队协作问题，在一些项目负责人面试的时候可以用到，我们在开发中肯定会遇到和产品，和后端有配合出问题的情况，虽然平时可以戏谑杀个产品祭天啥的，但是面试的时候，是需要将场景具体化的，并且还要展示出你的一个沟通和解决过程。因为这个问题我并没有好好准备，所以这里就即兴说了一通，这也导致我当时就觉得凉凉月色了，后面的问题回答得也比较紧张。 Java 项目用 Koltin 重构遇到的坑 因为我之前做的某个项目是一个重构项目，是由 Java-&gt;Kotlin 的，所以被问到了这个问题。当时听了这个问题我内心又是一阵懵逼，坑是肯定是有的，但是因为平时没有注意到这些，有坑就 Google 一下解决了，没有总结，导致真正面试的时候一时半会想不起来。所以也就答得不是太好。下面是我一些我下来总结的一些坑： Java 中的变量不用注解修饰的话，Kotlin 对他的可空性是模糊的 Kotlin 中掉 Java 中使用了 Kotlin 关键字的属性或者方法，必须使用反引号区分 Java 掉 Kotlin 的伴生对象方法，必须通过内部的 Companion 对象调用 Java 调用 TopLevel 的属性时，需要使用对应的名为 Kotlin 对应的类名 + Kt的类去索引 谈一谈队 Java 泛型的理解 这个又是一个比较空泛的问题，对于这种问题，如果我没有预先准备的话，我的回答能力是比较弱的，这也导致我这道题回答得不是太好，当时就感觉夜凉如水了。面试后的总结：Java 泛型是 JDK1.5 之后的一个新特性，他可以帮助我们参数化类型。我觉得泛型最大的作用是方便创建通用的，行为比较一致的类，比如最常见的 List 容器。在泛型出来之前，一般是利用 Object 来实现，但是这样有两个问题。第一个是每次使用的时候都会进行强转，第二个就是由于类型不确定，容易引发安全问题。而泛型通过编译时期的约束就解决了这样的问题。他会帮我们做一些隐士的转换，让我们更方便和更安全的使用。 什么是线程安全 线程安全是指一个类在多线程运行的情况下，不考虑运行环境下各种线程的交替运行，并且不做额外的同步，调用这个对象的方法都可以得到正确的结果，这样说这个对象是线程安全的。 为什么会导致线程不安全 我这次这个面试官很喜欢问类似的问题，就是一些很空泛的问题，这方面确实是我的软肋，比如这个问题就难到我了。当时扯了扯 JVM 内存模型相关的东西，但感觉没回答到点上。 Synhronized 和 Volatile 关键字的区别 Volatile 适用于不需要保证原子性，但却需要保证可见性的场景，比如修改一个 Boolean 变量的值，在这种情况，他是能做到线程安全的。 Synchronized 保证了可见性和原子性（这里的原子性是指同一个时间只能由一个线程执行某个类的代码块） Volatile 只能修饰关键字，而 Synchronized 可以修饰普通方法和静态方法以及代码块。 对 MVVM 的理解 面试结果：未通过。面试当天晚上我就主动问了下 HR 面试结果，被告知未通过，和心里预期的结果一样，我也就死心了，继续准备接下来的面试。 获奖感言：这种类似的大厂的一面不会去问你比较复杂或者刁钻的问题。但是你必须对一些概念上的东西能有一套自己的说辞，并且对于自己过去的做过的项目要做到烂熟于胸。 周二周二没有面试，所以就在 Boss 上投了投简历，并且通过 V 站投了投下厨房，然后就复习了一天，准备好周三的面试。 周三 MetaApp （10:00 - 12:00） 这个公司很有意思，我在拉钩上面看了它下面的面试评价总结出：是一家实行 996 的公司，并且面试过程很繁琐，还需要做机试题，但是闲着也是闲着，我抱着去增长面试经验约了今天上午的面试。 10 点的时候到达了公司的楼下，因为疫情原因进不去，需要 HR 来接应我，就联系了 HR。HR 下来之后，接应了包括我在内的一大堆人，他们也是来面试的。到了公司前台之后，首先根据你的岗位给你一套笔试题到一个会议室里面去做，我去的时候会议室已经差不多坐满了人，大约有二十来个。 我拿到的笔试题目如下，两道算法题： 给定一串字符，去除字符中重复的字符，时间复杂度需要控制为O(n) 这个我直接用了 HashSet 来做。 两个只包含数字的字符串相加 从后到前相加就行，需要考虑长度不一致的情况，稍微繁琐一点，不过思路还是简单。 这两道算法题都是需要用笔手写的，完成后给到前台，前台会给开发看，如果通过会进入到下一轮。 等了一会儿开发拿着我的笔试题过来了，让我给他讲一下我做题的思路，讲完之后开发把我带到一个会议室，开始面试。 问到的问题： Android中实现异步的方式 new Thread Handler 类的 postRunnable() 方法 ThreadExecutor AsyncTask RxJava 或者 Courtines 自定义 View 或者 ViewGroup 的步骤 自定义View 需要重写 onMeasure() 方法并对 AT_MOST 这种测量模式进行处理，View 的默认实现是不支持这个模式的，因为他不知道你具体的长宽需要多少。 第二个就是需要重写 onDraw() 进行一个内容的绘制，这里需要注意对 Padding 属性的一个支持 增加对自定义属性的支持。在 styles.xml 中声明 declare_style，然后在构造函数中通过 TypedArray 类中去解析。 自定义ViewGroup 需要在onMearsure() 方法中去掉用所有子 View 的 onMeasure() 方法，完毕之后根据自己的特性来确定自己的宽高。 需要在onLayout() 方法去依次调用子 View 的 layout() 方法来摆放子 View 的位置。 ViewGroup 一般自己是不用绘制的，如果想绘制，调用 setWillNotDraw(false) 方法并重写 onDraw() 方法。 文件访问在不同版本的不同特性 Android 6.0 的运行时权限适配 Android 7.0 FileUri 的适配 常用的 List，Map，Set 常见的有 ArrayList，LinkedList，HashMap，ConcurrentHashMap 以及 Android SDK 独有的 SparseArray，ArrayMap。最好把他们的底层原理都说一下，会增加面试官对你的好感。 问之前有使用过AOP编程没 答只有简单的了解，可以用来做点击事件防抖。然后听面试官科普了一下，还可以做登录拦截等等，算是学到了。 用了哪些设计模式以及使用场景 Git 常见命令，merge 和 rebase 的区别 四种常见的线程池的功能 写过 Gradle 脚本没有 不使用 temp 变量交换 a 和 b 可以使用加法:a = a + b;b = a - b;a = a - b;或者使用异或：a = a ^ bb = a ^ ba = a ^ b 方格中某一格到另一格的最短路径 这题不知道面试官想问什么，聊了半天他说可以用什么来抽象，因为只能右移或者下移，我答出了二叉树，应该是他的预期，答完了面谈纠结束了。 经过以上的面试，面试只是进行到了一个你有机会做笔试题的阶段。 千辛万苦，终于可以知道笔试题长什么样了，算是一个比较常见的需求，然后是在他们的台式电脑上开发。时间大概需要两三个小时吧，估计到这一步，就有很多人放弃了。不过我正做了半个小时，HR 就过来说让我们回家做，并加了我们的微信。走的时候差不多 12 点，这个时候发现一大批候选人就剩我和另一个哥们了，因为都是搞 Android 的，所以我们赶地铁的路上就一路闲聊了起来，听闻他已经拿了一个 30K 的 Offer，我只能表示慕了。 到这里，这家公司的面试暂时告一段落，还有后续。 上海勤壮（14:00 - 15:00） 这家公司算是我比较浪费时间的一次面试了。公司招聘信息这些都还挺好的，人数也是写的 100～500 人，但是到了面试地点我甚至怀疑我走错了地方。环境很像大学的实验楼，长长的走廊对称着有很多房间。 我试探性的敲了敲门，没想到里面还有人回应了，让我进去。进去发现里面就一张桌子，然后有 2 个人在里面，当时心就有点凉了。但是处于礼貌，还是走了走了流程。流程也是比较恶心，先是让你做一套笔记题，很老旧的那种型的选择题….做完之后还得继续填个单子，单子上要填写你的各种信息，简直就像查户口一样。我当时就想撂挑子了，不过还是忍住了。选择性的填了一些不是很敏感的信息，然后就开始面试。 和我聊的是一个有点秃头的中年大叔。他先问了我的之前的一些工作经历，也没问技术问题，就问我有没有什么需要了解的。于是我便问他们具体是做什么业务的。他回答说是帮国外手机厂商做 OTA 的升级包，我便反问他那不是系统层方面的东西吗？他回答说不是，只做 APK 行了，说什么国外的一些手机上市需要有 OTA 升级才行，总之十分含糊且不靠谱，硬撑着聊了一会儿，我直接说了不合适然后就离开了。 周四之前说过周二投了下厨房，然后面试约到了今天。因为我之前用过他们家的 App，而且听说他们的环境很不错，所以还是挺想加入他们的。因此这次面试可以说是我在北京最器重的一场面试了，我当时的想法就是如果能拿到下厨房的 Offer，基本也就在北京定下来了。所以面试前整个人的状态都是紧绷的。 因为是比较心仪的公司，下面的面试环节采用叙事的方式。 下厨房（14:30 - 17:30） 整个过程可以分为三轮，技术，项目经理和 HR，基本每人聊一个小时 技术 14:30 到达了公司，然后被安排到一个会议室等待，等待的时候观察了下他们的办公环境，确实是相对不错的环境。 过了一会儿一个技术老哥就拿着他的新款深灰 MBP 过来了，十分的骚气，然后也没让我做自我介绍，就直接开始了聊了。 老哥先是过了一遍我的简历，让把我之前的项目介绍了一下，然后一些技术点的实现讲了一下。因为之前的项目是用 MVP 模式做的，面试官让我把 MVP 的整个一个框架在纸上画出来，并描述每一层的职责，并说出了一些常见的场景问我是怎么处理的。 项目介绍完了之后，面试官提议问能不能看下我之前做的公司项目。因为我之前做的项目是面向一些特定企业的，并且是需要账号登录的，所以我手机上没有，也就算了。 然后面试官说看了我的博客，因为我写过一篇逆置单链表的算法博客，于是面试官就让我手写一下这个算法。不得不说面试官真是十分的 Nice 啊，让我写写过的算法，那还不是信手拈来。于是我三下五除二就用递归写出来了；写完之后，面试官又让我把另一种使用临时 Node 的解法也写出来。另一种方式其实有点绕，但是如果画个图也很好写，我当时急着写卡顿了一下，面试官就提示我让我先思考一下，于是我画了个图，然后跟着图顺利写出来了。 完了让我手写了一个 DCL 的单例，并问为什么要双重检查，以及为什么要加 Volatile 关键字。 写完了之后呢就进入到了一个比较尴尬的环节，问了我一些网络相关的题目。比如 Http 的方法有哪些，还问到了三次握手，四次挥手，Https 的实现原理等。因为网络这一块我是在是不想去背，并且自我感觉这些问题比较教条式，所以当时就直接坦白没有准备，回答不上。。。。这应该是我这场面试比较大的败笔了。 不过面试官也没说啥，问了问如何查看 View 的可见区域，这个我回答使用 View 的 getLocalVisibleRect()方法可以得知。 最后是问了一个问题，如果一次性向 HashMap 里面加入 100 条数据，为了减少扩容，应该设置初始容量为多少，这里主要是考虑负载因子对扩容的影响以及 HashMap 的扩容机制。 然后技术面试就结束了，持续了一个小时，总体感觉不错，面试官是很平易近人的，像是在聊天一样，自己有些地方没发挥好。 项目经理面试 这个面试是负责整个懒饭项目的项目负责人和我聊。 最开始也是让我展示一下以前做的 App，还是因为上面的原因手机上并没有，于是给他展示了下之前自己写的一个项目。 因为我的博客写了使用 Charles 抓包，于是他我如果想要抓取更底层的包怎么办？因为我之前使用过 WireShark，就说了使用这个工具，可以抓传输层的包。 然后他问了我 Charles 抓 Https 包的原理是什么？这里我只是简单回答了下通过代理。准备的来说应该是通过中间人攻击 + 伪造证书的方式。 然后让我把它当成一个新手介绍一下知乎 App 无限循环列表的实现方式，这里我主要讲了 ViewHolder 的一个大致的原理。 然后考了一个算法题，已知一个父 View 以及某个子 View以及他们的名字，要求打印这个子 View 的路径。我用递归做出来了，然后他让我用栈的方式实现，虽然知道栈可以实现 DFS ，但是不光需要查找，还需要打印路径，所以我想了一会儿直接说了做不出来。 然后就是问了Android 10 的新特性以及 App 启动页面的一个优化。 HR面试 他们家的 HR 感觉就是一种快问快答的面试方式，会快速的问各种问题，感觉很犀利。 和HR聊完就让回去等通知了，时间差不多都 6 点了，也就是聊了差不多三个小时。 面试结果：未通过。 获奖感言：如果再给我一次机会，我肯定会去背一背 Https 原理，也不会瞎要薪资，毕竟 14.8 薪并且朝九晚六不加班他不香吗？ 周五 二六三 （14:30 - 17:30） 这是一个做国外业务的上市公司，环境啥的都还不错，和下厨房类似，也是三轮紧凑的面试。 笔试 一个比较繁琐的 for 循环，然后有很多 i++ 或者 ++i，让你写出最后打印的值。 手写一个常用的单例。 技术 约束布局怎么隐藏多个布局？有什么缺点吗？ 如果想要一个 View 在某两个 View 的右边（不确定谁更宽），应该怎么做？ 最近项目遇到的一个问题？以及自己是怎么解决的。 如果一些数据想要让他自动过期应该怎么做？可以让后台配合。 TV 机顶盒开发和普通的开发有什么区别？ 常用的一些设计模式。 当收到通知，通知点击打开的界面的数据刷新是怎么做的。 项目经理 他们公司可能比较注重技术面，项目经理这里基本没怎么问问题，更多的是我在向他了解公司的情况。 HR面试 这个 HR 的面试方式我挺喜欢的，比较轻松。主要就是和你进行一个正常的聊天，聊美食，聊一些旅游过的地方，读过的书，一些爱好等等。会通过聊天来了解你，比较聊了差不多一个小时。 这个面试也差不多持续了三个小时。完了之后我就买了周六的机票回成都了。 面试结果：未通过。 获奖感言：这家公司看出来还是对我挺满意的，我的工资要得比较高，然后 HR 也让我加她微信聊一聊薪资的问题，但是因为他们的技术栈偏老，并且感觉团队不是很年轻化，我不是太喜欢所以薪资也就没妥协最后也就不了了之了。 成都面试回到成都之后，在周末找人内推了两家公司，一家是比较知名的 ThoughtWorks，另一家是成都本土的 Camera360。 在周二的时候，收到了 ThoughtWorks HR的一个电话面试，主要就是询问了一下之前的一些工作经历和自己的技术栈之类的，完了之后就给我安排了一个编程作业。 编程作业需要在三天内完成，于是接下来的三天，我都在认真的做作业了。期间在 Boss 上收到很多成都的公司给我打招呼，有的是外包公司还有很多小公司，我都没多大兴趣所以也都没有理睬。就这样到了周五，把完成了的作业发了过去。 然后周末休息了两天，又进入下一周。周三的时候，收到 HR 这边的反馈，作业已经通过了，会安排进入下一个环节，结对编程，时间是在周五。之前没经历过这种面试，也不知道结对编程是个啥。网上查了下大概得知是围绕之前的编程作业展开。所以这两天就各种熟悉之前的编程作业。 周五的时候，在忐忑不安中开始了传说中结对编程。主要是讲一下自己编程作业的一个设计思路以及遇到的问题和解决思路，然后会对一些技术选用进行交流。完了之后会留四十分钟进行一个新需求的编写。需求编写其实和平时开发过程一样，可以查资料，也可以和面试官交流。我差不多 20 分钟完成了需求，然后运行了一下，达到了效果。因为提前完成了需求，于是就和面试官闲聊了一段时间，对跨平台技术的了解，平时的一些学习方法，等等。 因为整个过程比较流畅，所以结束了之后也就不出意外的收到了 HR 的反馈说面试通过了。准备给我安排终面，因为想在国庆之前拿到 Offer，所以我也就让终面安排在了下周一。听说前两面是比较难得，然后终面相对简单，所以对于终面，我也就没多大心里压力。但是，终面完成之后，还是惊出一身冷汗的。终面是由一个技术负责人和一个项目经理一起面，这次几乎没有技术问题，主要是对项目的一些流程进行询问，问到的问题大概如下： 之前有过代码 Review 吗？ 之前碰到项目延期的情况吗？怎么处理的？ 之前遇到过最大的困难是什么怎么解决的？ 和同事配合出现问题怎么处理的？ 因为之前都是在小公司，所以有些问题还是让我很难回答的，我需要在很短的时间内去措辞，并且要让我的表达很精炼，并且显得比较有水平。更糟糕的事情是，终面的时候，不知道是什么原因，我的网络波动特别严重，于是中途还断线重连了几次，这让本来就感觉回答不好的我感到雪上加霜，一度感觉凉凉了，后面很多问题就想到啥说啥了，也没有刻意的去组织语言。 终面完了之后，我心里有一些些没底。但是在忐忑中收到 HR 的反馈，面试通过了，并且看了反馈，评价是还不错的，可能之前的一些担忧是多虑的吧。 接下来就是谈薪定 Offer 了，完了之后差不多赶在国庆的前两天，我拿到了 Offer。因为 ThoughtWorks 这个公司我是早有耳闻的，并且也是我比较憧憬的外企公司，所以也就准备国庆后去光速入职了。 插曲 MetaApp 之前说过这个公司让我们下去继续完成笔试题，于是我利用晚上的时间做了然后提交了。后面一直等到我回成都，这边 HR 通知我机试题过了，让我和那边的技术负责人聊一聊。因为我已经回到了成都，所以也就觉得没必要了，但是 HR 那边还是坚持了下，所以我也就同意了。 然后也是视频面试，手写了一个常用的排序以及斐波那契数列，然后问了一些之前项目上的事情。你来我往之后，面试官说他们现在实行的是一个 996 工作制，并且短时间内是不会取消的，然后我问有没有加班费，被告知没有，但是他说可以谈薪的时候找 HR 多要点，然后我明确表示了不会接受 996，所以也就拒绝了。 Camera360 这个公司我是找人内推的，但是一直没有给我安排面试，我以为是简历被刷了，于是问了下帮我内推的老哥，老哥说是面试人员太多，不过截止到 10.16，距离内推已经过去了一个月，还是没有给我任何消息 =。= 总结以上就是我 9 月求职的全过程，下面进行一些总结： 面试前一定要对自己的期望收入有一个明确的计算和规划，不同公司的薪酬体系是不同的，有一个明确的规划在谈薪资的时候可以展示出你的真诚。 平常做开发的时候，遇到什么问题一定要多做总结，这样的话在面试的时候也可以作为一定的谈资。 对于一些常见的技术点，不能只停留在会用的阶段，要能用书面化的表达方式表达出来。 面试一定要有耐心，边面试边总结，不要去薪资很低的公司，也不要去自己不想去的公司。","link":"/2020/10/17/一个Android猿的九月面试&杂谈/"},{"title":"聊一聊String，StringBuilder，StringBuffer","text":"String和StringBuilder以及StringBuffer的区别应该是我经历的面试中被问到的频率最高的问题之一。这里对这三者相关的东西做个总结吧。 一般遇到上面的问题，都会脱口而出：String是不可变的，而StringBuilder和StringBuffer是可变的。至于StringBuilder和StringBuffer的区别则是前者是线程不安全的，而后者是线程安全的。 听了这个答案，大部分面试官也就进入下一个问题了，深入一点的面试官可能还会问到如下问题： 为什么说String是不可变的？ 为什么String要设计成不可变的？有什么好处？ 为什么说StringBuilder和StringBuffer是可变的？ 为什么说StringBuilder是线程不安全的？ StringBuffer如何保证了线程安全？ 首先解释下这里说的不可变的意思，不可变是指String的内容不可变，也就是我们如果对String内容进行修改，那么必然会产生一个新的String对象(不考虑字符串常量池)。 问题一，为什么说String是不可变的？查看String类的源码，如下： 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; ............. } 首先该类被final关键字修饰，导致该类不可被继承；\u0014其次，存放内容的char[]被final关键字修饰，那么一旦构造函数执行后，该数组引用不可指向其他数组；再者，该类中除了构造方法之外，没有其他地方直接对value []的值进行修改。这三点保证了String类是不可变的。 问题二，为什么String要设计成不可变的？有什么好处？这种设计上的问题可以去so找一找答案。我找到了一个高赞答案总结下： 安全性。String变量常代表网络地址，用户名和密码等等作为参数传递。如果设计为可变的，这些参数很容易改变，容易导致代码安全问题。 同步和并发。将String作为不变的，天然解决了并发问题。 字符串常量池考虑。如果String可变，那么常量池就没了意义。这里举个例子：\u0003\u0003 123456String fooOne = \"foo\";String fooTwo = \"foo\";// 上面定义了两个变量。因为字符串常量池的设计，fooOne和fooTwo将指向同一内存地址。此时，我们进行如下操作：fooTwo = \"fooTwo\";// 此时，假如不存在String不可变的特性，那么会出现fooOne的内容也会变成\"fooTwo\"的情况，这显然是会出问题的，而String的不变性则解决了这个问题。 类加载。String被作为类加载的参数，如果它是可变的话，很容易导致错误的类被加载。 问题三，为什么说StringBuilder和StringBuffer是可变的？因为这两者源码几乎一模一样，所以这里拿StringBuilder举例子。查看StringBuilder源码，发现其继承于AbstractStringBuilder: 123456789101112abstract class AbstractStringBuilder implements Appendable, CharSequence { /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; ......} 可以发现，char[]没有被final修饰，并且多了个count属性用来表示已经使用的char字符的数量，很容易让人想到扩容机制。 再看StringBuilder的方法，多了一些诸如：append()，insert()，delete()等等方法，这也是支撑StringBuilder和StringBuffer可变的方法。 看看append方法的源码，其余方法原理都差不多： 12345@Overridepublic StringBuilder append(String str) { super.append(str); return this;} 内部调用了父类的方法： 123456789public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;} 首先调用 ensureCapacityInternal(count + len)确保char[]的长度足够容纳所有字符，看一下内部实现: 1234567891011121314151617181920212223242526272829303132 private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code if (minimumCapacity - value.length &gt; 0) { value = Arrays.copyOf(value, newCapacity(minimumCapacity)); } }private int newCapacity(int minCapacity) { // overflow-conscious code // 首先将现有的容量*2再加上2得到一个新的容量 int newCapacity = (value.length &lt;&lt; 1) + 2; // 如果新容量还是不够容纳 则直接使用minCapacity if (newCapacity - minCapacity &lt; 0) { newCapacity = minCapacity; } // 当newCapacity越界或者大于了MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8) return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity; } private int hugeCapacity(int minCapacity) { // 这个判断其实我有疑问，Inter.MAX_VALUE已经是最大的Int值，怎么还存在&lt;0 的情况，实际上当minCapacity越界时，这个等式是成立的 if (Integer.MAX_VALUE - minCapacity &lt; 0) { // overflow throw new OutOfMemoryError(); } return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE; } 确保char[]长度足够之后，调用了String的getChars方法。该方法注释为， Copies characters from this string into the destination character array. 也就是将自身的部分字符拷贝到指定char数组中，很好理解。 拷贝完成之后，char数组中的值已经得到了修改。 之后，更新count的值，append方法结束。 分析完部分源码，可以回答第三个问题，为什么StringBuilder和StringBuffer是可变的。因为在他们内部，char[]并没有被final修饰，因此可以在扩容之后，指向新的char数组 ；并且在追加新的字符时，会直接修改char[]的值。因此是可变的。 问题四，为什么说StringBuilder是线程不安全的？先写个代码测试一下： 1234567891011121314fun main(args: Array&lt;String&gt;) { val sb = StringBuilder() for (i in 0 until 10){ thread { for (j in 0 until 1000){ sb.append(\"1\") } } } Thread.sleep(2000) println(sb.length)} 分别开10个线程，对StringBuilder进行1000次的append操作。如果StringBuilder是线程安全的，那么打印出来的长度应该是10000. 可是实际上的结果是： 每次打印的结果均小于10000. 部分测试用例，还会存在 爆出java.lang.ArrayIndexOutOfBoundsException这个错误的情况。 先分析1，为什么每次打印的结果均小于10000. 试想这样一种情况，AB两个线程刚好同时对value[]进行了append操作，此时双方都到了更新count的代码处，假如此时，count的值为100，那么count最终的结果理应为102。可是，由于没有进行同步，两个线程几乎同时拿到100的值，然后分别对其+1操作，然后再设置count的值为101，因此，本身append了2次的值却只有一次生效了。也就导致最终使StringBuilder的length小于预期情况。 再分析2，为什么会出现爆出java.lang.ArrayIndexOutOfBoundsException的情况。 看了下，这个报错出现在str.getChars(0, len, value, count)方法内部，具体在System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin)这一行代码中。 先画个图理解下System.arraycopy方法： 根据图片概括就是，src从srcPos开始往des的desPos处复制length长度的数据。而这个desPos对应我们的count。因为处于多线程环境中，可能另一个线程刚好完成了append，使得count+1，因此，拿到的count就预期的多了1，导致了这个Exception。 问题五，StringBuffer如何保证了线程安全？这个看了源码就很好回答了。 StringBuffer通过对方法使用synchronized关键字加锁来保证线程安全。 结尾StringBuild看似源码比较简单，但是源码中对overflow的处理以及对System.copy函数的灵活使用，还是很值得学习和借鉴的。","link":"/2020/08/24/聊一聊String，StringBuilder，StringBuffer/"},{"title":"解决Gradle下载自身缓慢的问题","text":"本文讨论的是 Gradle 下载自身缓慢的问题，也就是在 Build 之前，由于不同 Android 项目依赖不同的 Gradle 版本，如果本地 Wrapper 文件夹中不存在该版本，则需要联网下载，而这个下载，是极其缓慢的，并且代理软件对其的下载速度是无影响的。这里有两种方式去解决。 1. 手动下载大法这个方法应该搞 Android 开发的人都尝试过。也就是新启动一个项目的时候，在 Android Studio 下载 Gradle 阶段，我们强制杀掉 Android Studio ，并从项目的 gradle-wrapper.properties 文件中获取到对应的 Gradle 版本；然后 Google搜索gradle distributions ,进入 https://services.gradle.org/distributions/ 页面进行对应 Gradle 的下载。下载完成之后，将其移动到对应的 Wrapper 目录，再重新打开项目即可。 2. 通过命令行代理这个方法是我在知乎的一个答案发现的，[原答案链接](大家都是怎样处理Gradle中的这个文件下载慢的问题的？ - 啊鱼的回答 - 知乎 https://www.zhihu.com/question/37810416/answer/156162582) 。他的原理是如果使用 Android Studio 来下载 Gradle ，由于权限问题，即使你的代理软件设置全局模式，下载 Gradle 也不会走代理，但是用命令的方式是可以做到的。 具体的代码如下： 1./gradlew -DsocksProxyHost=127.0.0.1 -DsocksProxyPort=7890 tasks 其中的 port 根据自己的代理软件进行替换，我用软件的是 ClashX，默认代理端口是 7890，经过测试，使用该方式之后，之前一直下载缓慢的 Gradle 也能在终端快速的下载。 吐槽不得不说，作为一名中国的开发者，因为墙的问题，在 Android 开发的道路上得多走好多的弯路。希望有一天，这个世界会没有墙的存在。","link":"/2020/10/13/解决Gradle下载自身缓慢的问题/"},{"title":"重拾Hexo","text":"前言闲来无事用GitPage部署了一个Hexo博客。之前其实也搞过，只不过是用的自己的腾讯云+自己买的域名。然后过期了之后就没搭理了。使用这一套的话自己不用去管服务器之类的，GitHub赛高。 过程 参考：&lt;使用 Hexo &amp; GitPage 搭建博客&gt; 耗时：1.5 h左右 选用主题：hexo-theme-icarus 遇到的坑：部署到GitHub时提示Permisstion denied.参考git-ssh 配置和使用配置了SSH之后搞定。 hexo特殊操作 hexo多标签 tags: [标签1,标签2,标签3] 自动摘要 另起一行键入 &lt;!-- more --&gt; 插入封面 在title处加上属性thumbnail: /thumbnail/xxx.jpg 本地部署 hexo s 部署到github hexo d 纯净部署 hexo clean &amp; hexo d 结语有一段时间没写博客了，以后一定要多多输出。","link":"/2019/08/04/重拾Hexo/"},{"title":"路口","text":"记得是 2016 年，也就是大二的时候，一位室友过二十岁的生日，于是另一位室友在 KTV 为他唱了一首 《二十岁的眼泪》，是张宇在《我是歌手》里的版本。当时我应该是第一次听这首歌，但是仿佛有一种熟悉的感觉，一下就喜欢上了。于是回去就去搜这首歌听，才发现原唱是陈升，而这首歌也是他送给他徒弟金城武二十岁生日的歌。 陈升对写歌的态度是，写歌需要主动去找寻灵感，需要经历，需要故事。而当时作为他徒弟的金城武，创作的方式确是每天把每天关在房间，绞尽脑汁的创作。于是陈升大骂金城武写的歌只不过是堆砌的音符，缺乏灵魂。因此金城武摔了吉他，发誓不再写歌，从此跨入影坛。后面的事情就不用说了，金城武在影坛的事业发展得如日中天，于是他们之间的师徒关系变得疏远，用陈升的话说就是“他已经是一个断线的风筝，飞得好远好远，我已经抓不住了。” 以上内容我在网上看到的一些报道和描述，未免有些夸张的成分，不过还是挺有意思。 《路口》这首歌是升哥的所有歌中我最喜欢的几首之一。而这首歌的作曲，就是上文提到的金城武，配上升哥充满意境的歌词，很容易产生共鸣。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748路口词：陈升曲：金城武昙花在夜里绽放静静地像在述说在夜里忽然想起了什么当我们必须遗忘习惯于宿命过往生命就不在是恍惚年少你我相逢在迷惘十字路口忘了问你走哪个方向也许有天我拥有漫天太阳却一样在幽暗的夜里醒来燕子回到了遥远的北方你的面孔我已想不起来别问我 生命太匆忙夕阳淹没就告别了今天你的名字我已想不起来别怪我 生命太匆忙花朵在夜里歌唱岂止是想起昨天莫非是因为歌的旋律有你我没有好的信仰脑子有绮丽幻想在生命歌里 将一无所有我不害怕 人生何其短但是我恐惧一切终必要成空时光的河悠悠的唱告别了今仍不知忏悔燕子回到了遥远的北方你的名字我已想不起来时光也不能挽留夕阳淹没就告别了今天你的名字的已想不起来别怪我 生命太匆忙你在记忆中走过了一回岁月寂寥 因有你而喜悦别问我 为什么流泪你的眼泪是遥远的星光却在寒夜里轻唤我醒来别问我 不曾挽回 在我看来这首歌就是在讲相逢，别离，和回忆。 “你我相逢在迷惘十字路口，忘了问你走哪个方向” 我们在生命中的某个节点遇到一些人，发生一些故事。但是随着生命的推移，我们不得向前走，去到下一个路口，遇到其他不同的人。也许我们有天会忍不住的想，之前相遇的那些人都去了哪里，在干什么，过得好吗？ “也许有天我拥有漫天太阳，却一样在幽暗的夜里醒来” 这句歌词是最打动我的一句话。也许我们有天在新的环境，过上了全新的生活，但是拥有恋旧内核的人，却会常常想起往事，甚至偶尔会在梦中梦到一些往事，然后惊醒。 “你在记忆中走过了一回，岁月寂寥因有你而喜悦” 也许有些人我们永远都不会相见，但是我会永远记住曾经蹉跎岁月一起度过的喜悦的时光。","link":"/2020/10/18/路口/"},{"title":"逆置单链表","text":"逆置单链表算是比较经典的链表题了，面试中出现得比较多；虽然它比较简单，但是解法比较多，并且涉及到了递归和复杂度，这里做个总结。 LeetCode上的题目如下： LeetCode - 206. Reverse Linked List Reverse a singly linked list. 解法一，使用数组 12345678910111213141516171819202122class Solution { fun reverseList(head: ListNode?): ListNode? { if (head?.next == null) return head val nodeList = mutableListOf&lt;ListNode&gt;() var vhead = head while (vhead != null){ nodeList.add(vhead) vhead = vhead.next } nodeList.forEachIndexed { index, listNode -&gt; if (index == 0) { listNode.next = null } else { listNode.next = nodeList[index -1] } } return nodeList.last() }} 思路很粗暴，使用一个数组保存所有链表的引用，然后遍历进行逆置。需要注意的是第一个节点的next应该指向null，然后应该返回数组的最后一个节点。这个写法很不简洁。即使是用Kotlin，代码依旧十分的冗长。如果追求简洁，可以使用递归，详见解法二。 解法二，递归 12345678910class Solution { fun reverseList(head: ListNode?): ListNode? { if (head?.next == null) return head val newHead = reverseList(head.next) head?.next?.next = head head?.next = null return newHead }} 这里假设我们的函数能逆置某个单链表并返回头节点，而第一个if语句是递归的终点。而下面的代码怎么理解呢？看下图，假如一个顺序为1，2，3，4的单链表在某个递归时刻进行到了如下这一步。如图： 此时，要完成逆置，我们需要使用 head?.next?.next = head将4号节点链接到了尾部，即2号节点的后面；此时1号节点的next节点还是2号节点，因此需要 head?.next = null来进行置空处理。借助图，也比较好理解逆置的流程。 递归写法虽然比较简洁，但是对栈帧有大量消耗，并且时间复杂度比较高，因此还有一种借助临时节点来逆置的算法。 解法三，使用临时节点。 思路是，我们使用一个NEWHEAD临时节点保持指向逆置后的头节点，并不断对原链表进行解构重组。 如图为某个时刻各自的指向： 结合图可以光速写出代码： 123456789101112131415class Solution { fun reverseList(head: ListNode?): ListNode? { if (head?.next == null) return head var newHead:ListNode? = null var vhead = head while (vhead != null) { val next = vhead.next vhead.next = newHead newHead = vhead; vhead = next; } return newHead; }} 这种解法时间复杂度为O(n)，并且没有消耗栈帧，算是一种比较推荐的解法。 结语以上就逆置单链表常见的三种解法了，发现链表题如果想不明白画画图就很容易理解了。顺便吐槽一下用Kotlin写链表题的时候，由于函数参数默认是val的，所以不得不每次用一个var变量去遍历，还是挺麻烦的。","link":"/2020/06/29/逆置单链表/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"随想","slug":"随想","link":"/categories/随想/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}